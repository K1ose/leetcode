# 1775 通过最少操作次数使数组的和相等

> 给你两个长度可能不等的整数数组 `nums1` 和 `nums2` 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。
>
> 每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。
>
> 请你返回使 `nums1` 中所有数的和与 `nums2` 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。
>
>  
>
> 示例 1：
>
> 输入：`nums1 = [1,2,3,4,5,6]`, `nums2 = [1,1,2,2,2,2]`
> 输出：3
> 解释：你可以通过 3 次操作使 `nums1` 中所有数的和与 `nums2` 中所有数的和相等。以下数组下标都从 0 开始。
>
> - 将 `nums2[0]` 变为 6 。 `nums1 = [1,2,3,4,5,6]`, `nums2 = [6,1,2,2,2,2]` 。
> - 将 `nums1[5]` 变为 1 。 `nums1 = [1,2,3,4,5,1]`, `nums2 = [6,1,2,2,2,2]` 。
> - 将 `nums1[2]` 变为 2 。 `nums1 = [1,2,2,4,5,1]`, `nums2 = [6,1,2,2,2,2]` 。
> 示例 2：
>
> 输入：`nums1 = [1,1,1,1,1,1,1]`, `nums2 = [6]`
> 输出：-1
> 解释：没有办法减少 `nums1` 的和或者增加 `nums2` 的和使二者相等。
> 示例 3：
>
> 输入：`nums1 = [6,6]`, `nums2 = [1]`
> 输出：3
> 解释：你可以通过 3 次操作使 `nums1` 中所有数的和与 `nums2` 中所有数的和相等。以下数组下标都从 0 开始。
>
> - 将 `nums1[0]` 变为 2 。 `nums1 = [2,6]`, `nums2 = [1]` 。
> - 将 `nums1[1]` 变为 2 。 `nums1 = [2,2]`, `nums2 = [1]` 。
> - 将 `nums2[0]` 变为 4 。 `nums1 = [2,2]`, `nums2 = [4]` 。
>
>
> 提示：
>
> 1 <= `nums1.length`, `nums2.length` <= 105
> 1 <= `nums1[i]`, `nums2[i]` <= 6
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 思路

根据要求，先剔除没办法通过修改使得二者和相等的情况。例如，当 `nums1` 的数目为 8 时，那么该数组的和的范围为 $[8,48]$ 。当 `nums2` 的和在这个范围之外时，将返回 `-1` 。设 `len1 = nums1.size()`，`len2 = nums2.size()`。即，当 `len1` > `len2` 时，如果 `len1`  > `len2` * 6，说明即使把 `nums2` 的元素都修改为最大值 6 ，其和也无法与 `nums1` 的和相等 。

有如下代码：

```cpp
if (len1 > len2)
{
	if (len1 > len2 * 6)
		return -1;
}
else
{
	if (len2 > len1 * 6)
		return -1;
}
```

如果 `len1` ≤ `len2`*6，计算具体的修改次数。此时，计算两个数组的差值。

得到的差值与调整次数相关：

- 差值小于等于5，则一次修改即可完成。
- 差值大于5且小于等于10，则需要两次修改。
- ...

因此，计算差值/5的值并向上取整，即可得到修改次数。