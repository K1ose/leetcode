/* 2488. 统计中位数为 K 的子数组

给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。

统计并返回 nums 中的 中位数 等于 k 的非空子数组的数目。

注意：

    数组的中位数是按 递增 顺序排列后位于 中间 的那个元素，如果数组长度为偶数，则中位数是位于中间靠 左 的那个元素。
        例如，[2,3,1,4] 的中位数是 2 ，[8,4,3,5,1] 的中位数是 4 。
    子数组是数组中的一个连续部分。



示例 1：

输入：nums = [3,2,1,4,5], k = 4
输出：3
解释：中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。

示例 2：

输入：nums = [2,3,1], k = 3
输出：1
解释：[3] 是唯一一个中位数等于 3 的子数组。



提示：

    n == nums.length
    1 <= n <= 105
    1 <= nums[i], k <= n
    nums 中的整数互不相同

 */
#include "../tools/program_head.h"
#include "../tools/display.h"
using namespace std;

class Solution
{
public:
    /* 子数组前后缀和+hash */
    /*
    如果要包含中位数 k,则子数组中一定要存在 k
    1. 讨论 子数组长度为奇数 的情况：
        - k 如果是子数组的中位数，意味着：子数组中，小于 k 的元素个数 = 大于 k 的元素个数

        - 如果子数组不是一个已排序数组，那么意味着：
            子数组中，
                k的左侧 小于k的元素+ k的右侧 小于k的元素 = k的左侧 大于k的元素 + k的右侧 大于k的元素
            可以转换为：
                左侧小于-左侧大于 = 右侧大于-右侧小于

        - 由于我们统计的是元素的个数，所以可以这样替换：
            左侧小于用1替代
            左侧大于用-1替代
            右侧大于用1替代
            右侧小于用-1替代
            中位数k用0替代
        - 那么对于例子{3,2,1,4,5},k=4，可以转换为{1,1,1,0,1}，为了满足题目条件：
            1. 左侧小于-左侧大于 = 右侧大于-右侧小于
            2. 子数组必定包含中位数k
          我们从下标3（k=4）开始计算前后缀和：
            - 倒序枚举子数组左端点，得到{0,1,2,3}
            - 正序枚举子数组右端点，得到{0,1}
          用哈希表cnt可以得出：总共有2个奇数长度的数组 cnt[0]+cnt[1] =2

        - 重新找一个例子加以理解，{1,8,7,4,5,6,2},k=5，可以转换为{1,-1,-1,1,0,1,-1}
            1. 左侧小于-左侧大于 = 右侧大于-右侧小于
            2. 子数组必定包含中位数k
          我们从下标4（k=5）开始计算前后缀和：
            - 倒序枚举子数组左端点，得到{0，1，0，-1，0}
            - 正序枚举子数组右端点，得到{0，1，0}
          可见满足条件的奇数长子数组共7个：cnt[0]+cnt[1]+cnt[2]=3+1+3=7
    2. 讨论 子数组长度为偶数 的情况：
        - 对于 中位数k 而言，对应题目要求
            左侧小于 = 右侧大于-1
          转换为：
            左侧小于+右侧小于 = 左侧大于+右侧大于-1
            左侧小于-左侧大于 = 右侧大于-右侧小于-1
        - 同样进行转换：
            左侧小于用1替代
            左侧大于用-1替代
            右侧大于用1替代
            右侧小于用-1替代
            中位数k用0替代
        - 对于例子{3,2,1,4,5},k=4，可以转换为{1,1,1,0,1}，为了满足题目条件：
            1. 左侧小于-左侧大于 = 右侧大于-右侧小于-1
            2. 子数组必定包含中位数k
          我们从下标3（k=4）开始计算前后缀和：
            - 倒序枚举子数组左端点，得到{0,1,2,3}
            - 正序枚举子数组右端点，得到{0-1,1-1}，即{-1,0}
          由于只有cnt[0]相同，所以偶数长子数组中位数为k的只有1个

        - 对于例子{1,8,7,4,5,6,2},k=5，可以转换为{1,-1,-1,1,0,1,-1}
            1. 左侧小于-左侧大于 = 右侧大于-右侧小于-1
            2. 子数组必定包含中位数k
          我们从下标4（k=5）开始计算前后缀和：
            - 倒序枚举子数组左端点，得到{0，1，0，-1，0}
            - 正序枚举子数组右端点，得到{0-1，1-1，0-1}，即{-1，0，-1}
          由于cnt[-1],cnt[0]都存在，则偶数长子数组中位数为k的有1+3+1=5个
         */

    int countSubarrays(vector<int> &nums, int k)
    {
        /* hashmap，初始化中位数自身 */
        unordered_map<int, int> cnt{{0, 1}};
        /* find() 返回 iter+pos(k) */
        int pos = find(nums.begin(), nums.end(), k) - nums.begin();

        /* 中位数k 的左侧 */
        for (int i = pos - 1, sum = 0; i >= 0; i--)
        {
            /* 如果左侧小于，则+1; 如果左侧大于则-1 */
            sum += nums[i] < k ? 1 : -1;
            cnt[sum]++;
            print_umap(cnt);
            cout << endl;
        }

        /* 中位数k 的右侧 */
        /* cnt[0] 为 奇数子数组下 k 本身构成，cnt[-1] 为 偶数子数组下 k与大于k的相邻元素组成 */
        int res = cnt[0] + cnt[-1];
        for (int i = pos + 1, sum = 0; i < nums.size(); i++)
        {
            /* 如果右侧小于，则-1; 如果右侧大于则+1 */
            sum += nums[i] > k ? 1 : -1;
            /* 计算奇数长的子数组和偶数长的子数组下满足中位数为k的个数 */
            res += cnt[sum] + cnt[sum - 1];
        }
        return res;
    }
};

int main(int argc, char const *argv[])
{
    int k = 5;
    vector<int> nums = {1, 8, 7, 4, 5, 6, 2};
    Solution slt;
    cout << slt.countSubarrays(nums, k) << endl;
    return 0;
}
